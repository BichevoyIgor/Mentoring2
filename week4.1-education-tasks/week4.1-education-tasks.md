### Простые задачи:

#### Основные концепции многопоточности:

1. **Создайте поток с использованием класса `Thread`**: Напишите класс, который наследует `Thread` и выводит сообщение
   при запуске.

2. **Создайте поток с использованием интерфейса `Runnable`**: Напишите класс, реализующий `Runnable`, и запустите его в
   потоке.

3. **Сравните `run()` и `start()`**: Создайте и запустите поток, вызвав `run()` напрямую и через `start()`, и отметьте
   разницу.

4. **Инициализация и приоритет потоков**: Создайте два потока с различными приоритетами и выведите их в работу.

5. **Демон-поток**: Создайте поток, выполните его как демон и покажите, что происходит с его завершением при завершении
   основного потока.

#### Управление потоками:

6. **Использование `wait()` и `notify()`**: Реализуйте простую программу, использующую `wait()` и `notify()` для
   синхронизации выполнения двух потоков.

7. **Симуляция `interrupt()`**: Напишите поток, который выполняет долгую задачу, и прерывайте его через `interrupt()`.
   Почему ничего не вышло?

8. **Изучение состояний потока**: Разработайте приложение, которое выводит текущее состояние потока (NEW, RUNNABLE,
   BLOCKED, WAITING, TERMINATED).

9. **Изменение приоритета потока**: Напишите программу для изменения приоритетов у нескольких потоков и наблюдайте за
   изменением порядка их выполнения.

10. **Сравнение `stop()` и `interrupt()`**: Реализуйте поток, прерываемый обеими командами, и обсудите различия и
    последствия.

#### Проблемы многопоточности:

11. **Реализация deadlock**: Создайте сценарий, демонстрирующий deadlock, и обсудите, как его можно избежать.

12. **Демонстрация `race condition`**: Напишите программу, которая приводит к состоянию гонки, обновляя общую переменную
    из двух потоков.

13. **Использование `synchronized` для предотвращения `race condition`**: Примените `synchronized` к предыдущему
    примеру, чтобы устранить состояние гонки.

14. **Демонстрация работы `volatile`**: Создайте переменную с `volatile` и продемонстрируйте, как изменения в одном
    потоке видны другому.

15. **Пример взаимного исключения с `synchronized`**: Напишите класс с синхронизированными методами, показывающими
    взаимное исключение.

#### Дополнительные задачи:

16. **Синхронизация доступа к счётчику**: Создайте программу, которая конкурентно увеличивает общий счетчик несколькими
    потоками с использованием `synchronized`.

17. **Создание нескольких потоков и ожидание их завершения**: Создайте несколько потоков и используйте метод `join()`
    для ожидания их завершения.

18. **Использование `wait()` и `notifyAll()`**: Создайте класс с несколькими потоками, использующими `wait()`
    и `notifyAll()` для завершения работы.

19. **Реализация шаблона "Производитель-Потребитель"**: Напишите программу, демонстрирующую взаимодействие производителя
    и потребителя через общий буфер.

20. **Использование блока `synchronized` для уменьшения зоны блокировки**: Примените синхронизацию на уровне блока и
    объясните, когда это полезно.

21. **Показать примеры использования `volatile` для флагов остановки**: Напишите код, где поток проверяет флаг остановки
    с `volatile`.

22. **Реализация таймера с использованием `TimerTask` и потоков**: Напишите программу, запускающую периодическую задачу
    с использованием потоков.

23. **Создайте класс, управляемый потоками, для отслеживания параметров приложения**: Используйте `synchronized` для
    безопасности доступа к данным.

24. **Построение передачи данных между потоками**: Симулируйте передачу данных между двумя потоками через общую
    переменную.

25. **Модификация объекта несколькими потоками**: Напишите класс с `synchronized` методами для воспроизведения
    последовательных изменений.

26. **Проверка возможности создания и запуска множества потоков**: Создайте и запустите множество потоков, чтобы
    проверить их взаимодействие.

27. **Использование `volatile` для обеспечения консистентности флага**: Напишите программу для демонстрации флага
    остановки с `volatile`.

28. **Моделирование обслуживания запросов с многопоточностью**: Симулируйте серверное приложение, обрабатывающее
    многопоточные запросы.

29. **Синхронизация с вложенными блокировками**: Напишите пример с несколькими вложенными `synchronized` блоками.

30. **Запуск нескольких потоков из главного потока**: Создайте несколько потоков от главного потока и наблюдайте их
    выполнение.

### Сложные задачи:

1. **Реализация пула из потоков**: Напишите собственный реализацию пула потоков, которая управляет созданием и
   завершением потоков.

2. **Асинхронное управление задачами с `Future`**: Реализуйте систему управления асинхронными задачами с
   использованием `Future`, чтобы обрабатывать результаты параллельных вычислений.

3. **Многопоточная система бронирования**: Симулируйте многопользовательскую систему бронирования, используя концепции
   многопоточности для безопасности транзакций.

4. **Калькуляция факториала именем Монтгомери в многопоточности**: Разрабатывайте параллельный алгоритм для расчета
   факториалов с распределением задач по потокам.

5. **Разработка многопоточной системы, использующей `wait()`, `notify()`, и `interrupt()`**: Создайте систему, где
   потоки с помощью `wait()`, `notify()`, и `interrupt()` координируют друг друга и обрабатывают исключения корректно.

6. Напишите класс, который запускает 10к потоков. Каждый из которых 10к раз увеличивает переменную X. Попробуйте
   исправить код
